import {
  createPatternMatchers,
  matcher,
} from "../util/nodeMatchers";
import { NodeMatcherAlternative, SelectionWithEditor } from "../typings/Types";
import { SimpleScopeTypeType } from "@cursorless/common";
import { SyntaxNode } from "web-tree-sitter";
import { getNodeRange, unwrapSelectionExtractor } from "../util/nodeSelectors";
import { patternFinder } from "../util/nodeFinders";

// Generated by the following command:
// curl https://raw.githubusercontent.com/ganezdragon/tree-sitter-perl/ee1001210af5f32ba14d2ced834636548e1b6485/src/node-types.json \
// | jq '[.[] | select(.type|match("_statement")) | .type ]'
const STATEMENT_TYPES = [
  "ellipsis_statement",
  "for_simple_statement",
  "for_statement_1",
  "for_statement_2",
  "foreach_simple_statement",
  "foreach_statement",
  "if_simple_statement",
  "if_statement",
  "loop_control_statement",
  "loop_control_statement",
  "named_block_statement",
  "package_statement",
  "pod_statement",
  "require_statement",
  "single_line_statement",
  "unless_simple_statement",
  "unless_statement",
  "until_simple_statement",
  "until_statement",
  "use_constant_statement",
  "use_no_feature_statement",
  "use_no_if_statement",
  "use_no_statement",
  "use_no_subs_statement",
  "use_parent_statement",
  "when_simple_statement",
  "while_simple_statement",
  "while_statement",
];

const EXPRESSION_TYPES = [
  "array",
  "assignment",
  "begin",
  // MANY MORE TODO ...
];

const EXPRESSION_STATEMENT_PARENT_TYPES = [
  "begin",
  "block",
  "do",
  "do_block",
  "else",
  "lambda",
  "method",
  "then",
];

const assignmentOperators = [
  "=",
  "+=",
  "-=",
  "*=",
  "/=",
  "||=",
  "//=",
  "|=",
  "&&=",
  "&=",
  "%=",
  ">>=",
  "<<=",
  "^=",
];

const mapKeyValueSeparators = [",", "=>"];

const nodeMatchers: Partial<
  Record<SimpleScopeTypeType, NodeMatcherAlternative>
> = {
  map: "hash",
  list: "array",
  condition: matcher(
    patternFinder("while_statement[condition]"),
    unwrapSelectionExtractor,
  ),
  string: [
    "string_single_quoted",
    "string_double_quoted",
    "string_q_quoted",
    "string_qq_quoted",
  ],
  ifStatement: "if_statement",
  functionCall: [
    "call_expression",
    "call_expression_with_just_name",
    "method_invocation",
  ],
  comment: "comments",
  namedFunction: ["function_definition"],
  anonymousFunction: "anonymous_function",
  regularExpression: ["regex_pattern", "regex_pattern_qr"],
  collectionKey: "*[key]", // TODO: child of "value: hash?"
  collectionItem: "*[value]", // TODO: child of "value: hash?"
  argumentOrParameter: [
    "empty_parenthesized_argument",
    "parenthesized_argument",
    "argument",
  ],
  className: "package_name",
};

export const patternMatchers = createPatternMatchers(nodeMatchers);

export function stringTextFragmentExtractor(
  node: SyntaxNode,
  _selection: SelectionWithEditor,
) {
  // heredoc_content does not seem to supported by tree-sitter-perl,
  // leaving it anyway since it won't hurt
  if (node.type === "string_content" || node.type === "heredoc_content") {
    return getNodeRange(node);
  }

  return null;
}

// EOF
